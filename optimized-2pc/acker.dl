.input participants `repeat_iter(peers.clone()) -> map(|p| (p,))`
.output clientOut `for_each(|(slot,payload):(u32,u32)| println!("completed {:?}: {:?}", slot, payload))`

.input periodic `source_stream(periodic_source) -> map(|_| ())`
.output throughputOut `for_each(|(num,):(u32,)| println!("completed {:?} entries", num))`

.async ackFromParticipant `null::<(u32,u32,u32,)>()` `source_stream(ack_from_participant_source) -> map(|v| deserialize_from_bytes::<(u32,u32,u32,)>(v.unwrap()).unwrap())`


unanimous(count(addr)) :- participants(addr)

AllAcks(s, payload, src) :+ AllAcks(s, payload, src), !completed(s, payload)
AllAcks(s, payload, src) :- ackFromParticipant(s, payload, src)

NumAcks(s, payload, count(src)) :- AllAcks(s, payload, src)
completed(s, payload) :- NumAcks(s, payload, num), unanimous(num)
// clientOut(s, payload) :- completed(s, payload)

NumCompleted(count(s)) :- completed(s, payload)
totalCompleted(new) :+ !totalCompleted(prev), NumCompleted(new)
totalCompleted(prev) :+ totalCompleted(prev), !NumCompleted(new)
totalCompleted(prev + new) :+ totalCompleted(prev), NumCompleted(new)
throughputOut(num) :- totalCompleted(num), periodic()