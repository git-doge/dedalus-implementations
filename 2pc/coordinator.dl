// topics
// - 2pc no votes? *(yes, since no timeout)
// - access time for timers in sugar dedalus *(not needed)
// - how to enforce serial ids if we can expect concurrent incoming messages *(aggr with choose)
// - is update the same as having succ(t, t') (fact goes into effect next timestep)? if not what does :+ do and how can we impl succ(t, t') *(yes)

// questions for david (about 2pc in general tbh):
// - if the coordinator in 2pc times out when trying to reach a participant, they send a rollback
// - but then the coordinator refuses to move on until its received unanimous acks
// - why are we willing to wait for down participants when acking but not when querying for commits?
// - either way the system as a whole is blocked until the machine is back up

// questions for david about sugary dedalus
// - how can we access time for timers?

.input clientIn
.output clientOut

.output voteToParticipant
.input voteFromParticipant
.output instructToParticipant
.input ackFromParticipant

unanimous(size)

commitInstruct(type)
rollbackInstruct(type)

success(res)
reject(res)

AllMsg(msg) :+ AllMsg(msg)
message(...) :+ ...
// ... other persist stuff here

AllMsg(msg) :-
    clientIn(msg)

NextMsgToAssign(choose(msg)) :-
    AllMsg(msg),
    !message(_, msg)

message(i, msg) :+
    NextMsgToAssign(msg),
    NextID(j),
    i == j + 1

NextID(max(i)) :-
    message(i, _)

// should i initialize nexttogo with 0?
NextToGo(i) :-
    lastMsgFinalized(j, _),
    i == j + 1

voteToParticipant@addr(i, msg) :~
    participantAddr(addr), # send to all participants
    message(i, msg), # getting the next message
    NextToGo(i) # everything before it must be fully resolved

EveryVote(i, msg, res, l_from) :-
    voteFromParticipant(i, msg, res, l_from)

YesVotes(i, msg, count(l_from)) :-
    EveryVote(i, msg, res, l_from),
    success(res)

VotedNo(i, msg) :-
    EveryVote(i, msg, res, l_from),
    reject(res)

# send commit message
msgCommitted(i, msg) :-
    YesVotes(i, msg, size),
    unanimous(size),
    !msgAborted(i, msg) # can't be already aborted

instructToParticipant@addr(i, msg, type) :~
    msgCommitted(i, msg),
    participantAddr(addr),
    commitInstruct(type)

# send rollback message
msgAborted(i, msg) :-
    VotedNo(i, msg),
    !msgCommitted(i, msg) # can't be already committed

instructToParticipant@addr(i, msg, type) :~
    msgAborted(i, msg),
    participantAddr(addr),
    rollbackInstruct(type)

# collecting acks before moving on
Acks(i, msg, count(l_from))) :-
    ackFromParticipant(i, msg, l_from)

lastMsgFinalized(max(i), msg) :-
    Acks(i, msg, size),
    unanimous(size)